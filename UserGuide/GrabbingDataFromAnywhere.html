<!DOCTYPE html><html lang="en">  <head>    <meta charset="utf-8"></meta>    <link href="/UserGuide.css" rel="stylesheet"></link>  </head>  <body>    <main>      <h1>Grabbing Data From Anywhere</h1>      <p>FlipDB is a relational database management system that provides      for the formal definition of primary and foreign keys and a unique      and rich →[*.User_Guide.Joins|Join] syntax for pulling in data from      other tables.</p>      <p>However, in much ad-hoc analysis, a formal database with foreign      keys and referential integerity is simply not available. There is      simply data in various databases and tables, and in previously computed      query results that we need to access and incorporate into the current      query. FlipDB provides an easy way to directly access all of this      data.</p>      <p>The →[*.getColumn] function will directly access a column located      anywhere: in the same table, another table in the same database,      or in any other database:</p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>TotalBalance</code>            </td>            <td class="center">              <code>sum getColumn 'Loans.Balance'</code>            </td>          </tr>        </tbody>      </table>      <p>Note that a column accessed this way is not affected by the Where      clause. This provides one technique reaching out of the current context.</p>      <p>        The →[        <em>.getTable] function will get an entire table from the current        database or any other database, materializing it as a datatable.        It is usually conventient to apply the →[</em>        .transpose] function to convert the datatable to a propertyspace,        making it easy to dot into and access the columns:      </p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>StateInfo</code>            </td>            <td class="center">              <code>transpose getTable 'State'</code>            </td>          </tr>          <tr>            <td class="center">              <code>MTM</code>            </td>            <td class="center">              <code>StateInfo.MonthsToForeclose</code>            </td>          </tr>        </tbody>      </table>      <p>Data from previously executed queries in a Report may be direclty      accessed as propertyspaces in the Globals property space:</p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>UniqueStates</code>            </td>            <td class="center">              <code>Globals.GeographicDistribution.State</code>            </td>          </tr>        </tbody>      </table>      <p>Values accessed in any of these ways will generally be _non-conforming_.      That is, there is no reason to think that a column from another table      or query result will line up in any way with the current query. The      dimensions will be different. Sometimes this is acceptable. For example      if we are simply checking for elements in a list in a Where clause,      there is no need for the data to be conformable:</p>      <table>        <thead>          <tr>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">ZipCode in getcolumn 'HurricaneAffected.Zipcode'</td>          </tr>        </tbody>      </table>      <p>        However, many times we need to make the data conform is some way.        There are three common techniques for accomplishing this. First,        we may        <strong>aggregate</strong>        . For example:      </p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>AnnualTarget</code>            </td>            <td class="center">              <code>sum getColumn 'MonthlyTargets.Amount</code>              '            </td>          </tr>        </tbody>      </table>      <p>        Second, we may        <strong>enclose</strong>        . For example, we may have a table that contains time series data        for, say, default rates. The table is 360 rows long, and each column        contains a scenario, If we have 1000 mortgages in a main table        we can enclose the time series column so that the entire set of        360 values is applied to each mortgage:      </p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>DRS</code>            </td>            <td class="center">              <code>transpose getTable 'DefaultRateScenarios'</code>            </td>          </tr>          <tr>            <td class="center">              <code>CFI</code>            </td>            <td class="center">              <code>newPropertySpace ''</code>            </td>          </tr>          <tr>            <td class="center">              <code>CFI.Balance</code>            </td>            <td class="center">              <code>CurrentBalance</code>            </td>          </tr>          <tr>            <td class="center">              <code>CFI.Rate</code>            </td>            <td class="center">              <code>Rate</code>            </td>          </tr>          <tr>            <td class="center">              <code>CFI.DefaultRateScenario</code>            </td>            <td class="center">              <code>enclose DRS.Scenario1</code>            </td>          </tr>        </tbody>      </table>      <p>        Third, we may perform a        <strong>lookup</strong>        , to line-up the data in a datatable or propertyspace with the        current query. Consider a database table named        <code>ForeclosureInfo</code>        that contains 50 rows, one for each state:      </p>      <table>        <thead>          <tr>            <th class="center">State</th>            <th class="center">Months</th>            <th class="center">LegalFees</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">NY</td>            <td class="center">24</td>            <td class="center">2,200</td>          </tr>          <tr>            <td class="center">CA</td>            <td class="center">18</td>            <td class="center">3,400</td>          </tr>          <tr>            <td class="center">SD</td>            <td class="center">2</td>            <td class="center">375</td>          </tr>          <tr>            <td class="center">FL</td>            <td class="center">7</td>            <td class="center">975</td>          </tr>          <tr>            <td class="center">...</td>            <td class="center">...</td>            <td class="center">...</td>          </tr>        </tbody>      </table>      <p>Consider further that the current query is a simple loan list:</p>      <table>        <thead>          <tr>            <th class="center">LoanID</th>            <th class="center">PropertyState</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">101</td>            <td class="center">CA</td>          </tr>          <tr>            <td class="center">102</td>            <td class="center">CA</td>          </tr>          <tr>            <td class="center">103</td>            <td class="center">NY</td>          </tr>          <tr>            <td class="center">104</td>            <td class="center">FL</td>          </tr>          <tr>            <td class="center">...</td>            <td class="center">...</td>          </tr>        </tbody>      </table>      <p>The →[*.conform] function can take this table and the name of      one or more columns that define a lookup key, and conform it to the      current query dimensions:</p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>ForcInfo</code>            </td>            <td class="center">              <code>PropertyState conform 'ForclosureInfo' 'State'</code>            </td>          </tr>        </tbody>      </table>      <p>It is convenient to →[*.transpose] the result to yield a propertyspace,      to subsequently access the columns. Thus a simple loan list might      be defined as:</p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>ForcInfo</code>            </td>            <td class="center">              <code>transpose PropertyState conform 'ForclosureInfo' 'State'</code>            </td>          </tr>          <tr>            <td class="center">              <code>LoanID</code>            </td>            <td class="center">              <code>LoanNumber</code>            </td>          </tr>          <tr>            <td class="center">              <code>PropertyState</code>            </td>            <td class="center">              <code>PropertyState</code>            </td>          </tr>          <tr>            <td class="center">              <code>MonthsToForclose</code>            </td>            <td class="center">              <code>ForcInfo.Months</code>            </td>          </tr>          <tr>            <td class="center">              <code>LegalFees</code>            </td>            <td class="center">              <code>ForcInfo.LegalFees</code>            </td>          </tr>        </tbody>      </table>      <p>And yield:</p>      <table>        <thead>          <tr>            <th class="center">LoanID</th>            <th class="center">PropertyState</th>            <th class="center">MonthsToForeclosure</th>            <th class="center">LegalFees</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">101</td>            <td class="center">CA</td>            <td class="center">18</td>            <td class="center">3,400</td>          </tr>          <tr>            <td class="center">102</td>            <td class="center">CA</td>            <td class="center">18</td>            <td class="center">3,400</td>          </tr>          <tr>            <td class="center">103</td>            <td class="center">NY</td>            <td class="center">24</td>            <td class="center">2,200</td>          </tr>          <tr>            <td class="center">104</td>            <td class="center">FL</td>            <td class="center">7</td>            <td class="center">975</td>          </tr>          <tr>            <td class="center">...</td>            <td class="center">...</td>            <td class="center">...</td>            <td class="center">...</td>          </tr>        </tbody>      </table>      <p>        The conform function works on an entire table. This is generally        fine for small lookup style tables, or previously computed grouped        query results. For very large tables with millions of rows and        a large number of columns, it can be inefficient. The →[        <em>.indexOf] (and →[</em>        .lookup]) and →[*.index] functions may be used to work on specific        individual columns of large tables in a more efficient, if more        verbose, way:      </p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>LoanID</code>            </td>            <td class="center">              <code>getColumn 'Tab1.LoanID'</code>            </td>          </tr>          <tr>            <td class="center">              <code>K</code>            </td>            <td class="center">              <code>Col1 indexOf LoanNumber</code>            </td>          </tr>          <tr>            <td class="center">              <code>Balance</code>            </td>            <td class="center">              <code>K index getColumn 'Tab1.Balance'</code>            </td>          </tr>        </tbody>      </table>    </main>  </body></html>
