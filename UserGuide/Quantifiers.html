<!DOCTYPE html><html lang="en">  <head>    <meta charset="utf-8"></meta>    <base href="/FlipDBDoc"/>    <link href="/UserGuide.css" rel="stylesheet"></link>  </head>  <body>    <main>      <h1>Repetition and Quantifiers</h1>      <p>        Repetition is specified using a        <em>quantifier</em>        . The most general form for a quantifier explicitly specifies the        minimum and maximum number of repetitions, separated by a comma,        enclosed in braces:      </p>      <pre>        <code>{n,m}</code>      </pre>      <p>To match 2 to 4 consecutive occurances of the character b:</p>      <pre>        <code>      regexMatch 'bbbbababbcbbb' 'b{2,4}'┌───────┐↓bbbb   ││bb     ││bbb    │└Char(4)┘</code>      </pre>      <p>Note the backslash here is a FlipDB escape for the comma, and      NOT a regex metacharacter. Literal arguments must first be processed      by FlipDB and the comma would indicate a string separator if not      escaped.</p>      <p>For no limit to the number of repetitions, leave off the maximum      using {n,}:</p>      <pre>        <code>      regexMatch 'The beautiful giant sequoias.' '[aeiou]{2,}'┌───────┐↓eau    ││ia     ││uoia   │└Char(4)┘</code>      </pre>      <p>For exactly n repetitions, use {n} with no comma:</p>      <pre>        <code>      regexMatch 'The beautiful giant sequoias.' '[aeiou]{3}'┌───────┐↓eau    ││uoi    │└Char(3)┘</code>      </pre>      <p>Regex provides shortcuts for the 3 most commonly used quantifiers:</p>      <p>Shortcut|Quantifier|Meaning * |{0,} |match 0 or more times + |{1,}      |match 1 or more times ? |{0,1} |match 0 or 1 time</p>      <h2>Greedy versus Non-Greedy Quantifiers</h2>      <p>Quantifiers attempt to match as much as possible up to the maximum      specified. This is called "greediness". Sometimes this behavior is      surprising. Consider looking for the character a, followed by an      unlimited number of any other character, followed by an e:</p>      <pre>        <code>      regexMatch  'abcdefghijke'   'a.+e'┌────────────┐↓abcdefghijke│└Char(12)────┘</code>      </pre>      <p>You might expect the match to be just "abcde", but the quantifier      + is greedy and it seeks the largest match possible, and thus matches      the whole string. A quantifier can be specified to be non-greedy      (also known as lazy) A lazy quantifier matches the fewest number      of repetitions. This is done by following the quantifier with a ?:</p>      <pre>        <code>   regexMatch  'abcdefghijke'   'a.+?e'┌───────┐↓abcde  │└Char(5)┘</code>      </pre>      <p>Matching HTML tags is a classic example of greedy versus non-greedy      behavior:</p>      <pre>        <code>      regexMatch  'To &lt;em&gt;be&lt;/em&gt;or &lt;em&gt;not&lt;/em&gt; to be'   '&lt;em&gt;.+&lt;/em&gt;'┌──────────────────────────┐↓&lt;em&gt;be&lt;/em&gt;or &lt;em&gt;not&lt;/em&gt;│└Char(26)──────────────────┘      regexMatch  'To &lt;em&gt;be&lt;/em&gt;or &lt;em&gt;not&lt;/em&gt; to be'   '&lt;em&gt;.+?&lt;/em&gt;'┌────────────┐↓&lt;em&gt;be&lt;/em&gt; ││&lt;em&gt;not&lt;/em&gt;│└Char(12)────┘</code>      </pre>      <p>Note well the difference.</p>    </main>  </body></html>
