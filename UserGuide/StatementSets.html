<!DOCTYPE html><html lang="en">  <head>    <meta charset="utf-8"></meta>    <link href="/FlipDBDoc/UserGuide.css" rel="stylesheet"></link>  </head>  <body>    <main>      <h1>Statement Sets</h1>      <p>        An expression set where all of the expressions are boolean valued        is termed a        <strong>statement set</strong>        . Statement sets may be executed using the →[        <em>.evaluateStatementSet] function. Note that Statement sets may        be used directly as the →[</em>        .GroupBy] property of a query.      </p>      <p>        Consider the statement set created and named as        <code>/Objects/DataProblems</code>        :      </p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>MissingLTV</code>            </td>            <td class="center">              <code>LTV eq 0</code>            </td>          </tr>          <tr>            <td class="center">              <code>InvaldState</code>            </td>            <td class="center">              <code>not okState State</code>            </td>          </tr>          <tr>            <td class="center">              <code>MissingMargin</code>            </td>            <td class="center">              <code>(RateType in 'A') and (Margin eq 0)</code>            </td>          </tr>        </tbody>      </table>      <p>This may be executed analyzed as:</p>      <table>        <thead>          <tr>            <th class="center">Name</th>            <th class="center">Expression</th>            <th class="center">Hide</th>          </tr>        </thead>        <tbody>          <tr>            <td class="center">              <code>DataProblems</code>            </td>            <td class="center">              <code>evaluateStatementSet '/Objects/DataProblems'</code>            </td>            <td class="center">              <code>1</code>            </td>          </tr>          <tr>            <td class="center">              <code>None</code>            </td>            <td class="center">              <code>none DataProblems</code>            </td>            <td class="center">              <code>0</code>            </td>          </tr>          <tr>            <td class="center">              <code>Any</code>            </td>            <td class="center">              <code>any DataProblems</code>            </td>            <td class="center">              <code>0</code>            </td>          </tr>          <tr>            <td class="center">              <code>All</code>            </td>            <td class="center">              <code>all DataProblens</code>            </td>            <td class="center">              <code>0</code>            </td>          </tr>        </tbody>      </table>      <p>        The result DataProblems is partiioned boolan column, with, in this        case, 3 values in each partition. The aggregate function →[        <em>none] returns a 1 for each row that has no problems. The aggregate        runction →[</em>        .any] returns a 1 for each row that has at least one problem. The        aggregate function →[*.all] returns a 1 for each row that has all        three problems.      </p>    </main>  </body></html>
